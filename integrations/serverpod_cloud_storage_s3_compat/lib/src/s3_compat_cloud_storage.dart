import 'dart:typed_data';

import 'package:http/http.dart' as http;
import 'package:serverpod/serverpod.dart';

import 'client/exceptions.dart';
import 'client/s3_client.dart';
import 'config/s3_endpoint_config.dart';
import 'upload/s3_upload_strategy.dart';

/// Base class for S3-compatible cloud storage implementations.
///
/// This class implements the [CloudStorage] interface using configurable
/// endpoint and upload strategy abstractions. Concrete implementations
/// only need to provide appropriate configuration.
///
/// Example:
/// ```dart
/// class MyS3Storage extends S3CompatCloudStorage {
///   MyS3Storage({required Serverpod serverpod, ...})
///     : super(
///         storageId: 'my-storage',
///         accessKey: ...,
///         secretKey: ...,
///         bucket: 'my-bucket',
///         region: 'us-east-1',
///         public: true,
///         endpoints: AwsEndpointConfig(),
///         uploadStrategy: MultipartPostUploadStrategy(),
///       );
/// }
/// ```
class S3CompatCloudStorage extends CloudStorage with CloudStorageWithOptions {
  /// The access key for S3 authentication.
  final String accessKey;

  /// The secret key for S3 authentication.
  final String secretKey;

  /// The bucket name.
  final String bucket;

  /// The region (e.g., 'us-east-1').
  final String region;

  /// Whether files in this storage are publicly accessible.
  final bool public;

  /// The endpoint configuration for this storage provider.
  final S3EndpointConfig endpoints;

  /// The upload strategy to use.
  final S3UploadStrategy uploadStrategy;

  late final S3Client _client;

  /// Creates a new S3-compatible cloud storage.
  ///
  /// [storageId] identifies this storage instance.
  /// [accessKey] and [secretKey] are the credentials for authentication.
  /// [bucket] is the target bucket name.
  /// [region] is the AWS region or equivalent.
  /// [public] indicates whether files should be publicly accessible.
  /// [endpoints] provides the URL patterns for this storage provider.
  /// [uploadStrategy] determines how files are uploaded.
  /// [client] can be provided for testing or custom HTTP handling.
  S3CompatCloudStorage({
    required String storageId,
    required this.accessKey,
    required this.secretKey,
    required this.bucket,
    required this.region,
    required this.public,
    required this.endpoints,
    required this.uploadStrategy,
    S3Client? client,
  }) : super(storageId) {
    _client =
        client ??
        S3Client(
          accessKey: accessKey,
          secretKey: secretKey,
          bucket: bucket,
          region: region,
          endpoints: endpoints,
        );
  }

  /// Closes the underlying HTTP client.
  ///
  /// Call this when the storage instance is no longer needed to free
  /// resources. After calling [close], no further operations should be
  /// performed on this instance.
  void close() {
    _client.close();
  }

  @override
  Future<void> storeFile({
    required Session session,
    required String path,
    required ByteData byteData,
    DateTime? expiration,
    bool verified = true,
  }) async {
    await uploadStrategy.uploadData(
      accessKey: accessKey,
      secretKey: secretKey,
      bucket: bucket,
      region: region,
      data: byteData,
      path: path,
      public: public,
      endpoints: endpoints,
    );
  }

  @override
  Future<ByteData?> retrieveFile({
    required Session session,
    required String path,
  }) async {
    final response = await _client.getObject(path);
    if (response.statusCode == 200) {
      return ByteData.sublistView(response.bodyBytes);
    }
    if (response.statusCode == 404) return null;
    _throwForResponse(response);
  }

  @override
  Future<Uri?> getPublicUrl({
    required Session session,
    required String path,
  }) async {
    if (!public) return null;

    if (await fileExists(session: session, path: path)) {
      return endpoints.buildPublicUri(bucket, region, path);
    }
    return null;
  }

  @override
  Future<bool> fileExists({
    required Session session,
    required String path,
  }) async {
    final response = await _client.headObject(path);
    if (response.statusCode == 200) return true;
    if (response.statusCode == 404) return false;
    _throwForResponse(response);
  }

  @override
  Future<void> deleteFile({
    required Session session,
    required String path,
  }) async {
    final response = await _client.deleteObject(path);
    // 204 = deleted, 404 = already gone â€” both are success.
    if (response.statusCode == 204 || response.statusCode == 404) return;
    _throwForResponse(response);
  }

  /// Throws an appropriate exception for a non-success response.
  Never _throwForResponse(http.Response response) {
    if (response.statusCode == 403) {
      throw NoPermissionsException(response);
    }
    throw S3Exception(response);
  }

  @override
  Future<String?> createDirectFileUploadDescription({
    required Session session,
    required String path,
    Duration expirationDuration = const Duration(minutes: 10),
    int maxFileSize = 10 * 1024 * 1024,
  }) async {
    return uploadStrategy.createDirectUploadDescription(
      accessKey: accessKey,
      secretKey: secretKey,
      bucket: bucket,
      region: region,
      path: path,
      expiration: expirationDuration,
      maxFileSize: maxFileSize,
      public: public,
      endpoints: endpoints,
    );
  }

  @override
  Future<void> storeFileWithOptions({
    required Session session,
    required String path,
    required ByteData byteData,
    DateTime? expiration,
    bool verified = true,
    required CloudStorageOptions options,
  }) async {
    await uploadStrategy.uploadData(
      accessKey: accessKey,
      secretKey: secretKey,
      bucket: bucket,
      region: region,
      data: byteData,
      path: path,
      public: public,
      endpoints: endpoints,
      preventOverwrite: options.preventOverwrite,
    );
  }

  @override
  Future<String?> createDirectFileUploadDescriptionWithOptions({
    required Session session,
    required String path,
    Duration expirationDuration = const Duration(minutes: 10),
    int maxFileSize = 10 * 1024 * 1024,
    required CloudStorageOptions options,
  }) async {
    if (options.contentLength != null && options.contentLength! > maxFileSize) {
      throw CloudStorageException(
        'Content length (${options.contentLength} bytes) exceeds maximum file size ($maxFileSize bytes).',
      );
    }

    return uploadStrategy.createDirectUploadDescription(
      accessKey: accessKey,
      secretKey: secretKey,
      bucket: bucket,
      region: region,
      path: path,
      expiration: expirationDuration,
      maxFileSize: maxFileSize,
      public: public,
      endpoints: endpoints,
      contentLength: options.contentLength,
      preventOverwrite: options.preventOverwrite,
    );
  }

  @override
  Future<bool> verifyDirectFileUpload({
    required Session session,
    required String path,
  }) async {
    return fileExists(session: session, path: path);
  }
}
