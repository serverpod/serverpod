import 'package:pub_semver/pub_semver.dart';
import 'package:pubspec_parse/pubspec_parse.dart';
import 'package:serverpod_cli/src/util/pubspec_lock_parser.dart';
import 'package:test/test.dart';

void main() {
  group('Given a valid pubspec.lock with hosted dependencies', () {
    const lockString = '''
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  analyzer:
    dependency: "direct main"
    description:
      name: analyzer
      sha256: "1f14db053a8c23e260789e9b0980fa27f2680dd640932cae5e1137cce0e46e1e"
      url: "https://pub.dev"
    source: hosted
    version: "6.11.0"
  test:
    dependency: "direct dev"
    description:
      name: test
      sha256: "a1f7595805820fcc05e5c52e3a231aedd0b72972721bba0b9596019ab6b85c42"
      url: "https://pub.dev"
    source: hosted
    version: "1.25.8"
  collection:
    dependency: transitive
    description:
      name: collection
      sha256: "ee5ef7bdaa094226e7896a68f05ab35bd8d6efac0e2e7b8e463d485b4b3c0d55"
      url: "https://pub.dev"
    source: hosted
    version: "1.18.0"
sdks:
  dart: ">=3.5.0 <4.0.0"
  flutter: ">=3.24.0"
''';

    group('when calling PubspecLockParser.parse', () {
      late PubspecLockParser parser;
      late Map<String, LockedPackage> packagesByName;

      setUpAll(() {
        parser = PubspecLockParser.parse(lockString);
        packagesByName = {for (var p in parser.allPackages) p.name: p};
      });

      test('then it returns correct number of packages', () {
        expect(parser.allPackages, hasLength(3));
      });

      test('then it returns packages with correct names', () {
        expect(
          parser.allPackages.map((p) => p.name),
          unorderedEquals(['analyzer', 'test', 'collection']),
        );
      });

      test('then it returns correct SDK constraints', () {
        expect(parser.dartSdkConstraint?.toString(), '>=3.5.0 <4.0.0');
        expect(parser.flutterSdkConstraint?.toString(), '>=3.24.0');
      });

      test('then analyzer package has correct dependency type', () {
        final analyzer = packagesByName['analyzer']!;
        expect(analyzer.dependencyType, DependencyType.directMain);
        expect(analyzer.isDirect, true);
        expect(analyzer.isDevDependency, false);
        expect(analyzer.isTransitive, false);
      });

      test('then analyzer package has correct version', () {
        final analyzer = packagesByName['analyzer']!;
        expect(analyzer.version, Version.parse('6.11.0'));
      });

      test('then analyzer package has correct source', () {
        final analyzer = packagesByName['analyzer']!;
        expect(analyzer.source, PackageSource.hosted);
      });

      test('then analyzer package has correct sha256', () {
        final analyzer = packagesByName['analyzer']!;
        expect(analyzer.sha256,
            '1f14db053a8c23e260789e9b0980fa27f2680dd640932cae5e1137cce0e46e1e');
      });

      test('then analyzer package has HostedDependency', () {
        final analyzer = packagesByName['analyzer']!;
        expect(analyzer.dependency, isA<HostedDependency>());
      });

      test('then test package has correct dependency type', () {
        final test = packagesByName['test']!;
        expect(test.dependencyType, DependencyType.directDev);
        expect(test.isDirect, true);
        expect(test.isDevDependency, true);
        expect(test.isTransitive, false);
      });

      test('then collection package has correct dependency type', () {
        final collection = packagesByName['collection']!;
        expect(collection.dependencyType, DependencyType.transitive);
        expect(collection.isDirect, false);
        expect(collection.isDevDependency, false);
        expect(collection.isTransitive, true);
      });

      test('then directDependencies returns only direct main dependencies', () {
        expect(parser.directDependencies, hasLength(1));
        expect(parser.directDependencies.first.name, 'analyzer');
      });

      test('then devDependencies returns only dev dependencies', () {
        expect(parser.devDependencies, hasLength(1));
        expect(parser.devDependencies.first.name, 'test');
      });

      test('then transitiveDependencies returns only transitive dependencies',
          () {
        expect(parser.transitiveDependencies, hasLength(1));
        expect(parser.transitiveDependencies.first.name, 'collection');
      });

      test('then hostedPackages returns all hosted packages', () {
        expect(parser.hostedPackages, hasLength(3));
      });

      test('then getPackage returns correct package', () {
        final analyzer = parser.getPackage('analyzer');
        expect(analyzer, isNotNull);
        expect(analyzer!.name, 'analyzer');
      });

      test('then hasPackage returns true for existing package', () {
        expect(parser.hasPackage('analyzer'), true);
      });

      test('then hasPackage returns false for non-existing package', () {
        expect(parser.hasPackage('nonexistent'), false);
      });

      test('then packageCountByType returns correct counts', () {
        final counts = parser.packageCountByType;
        expect(counts[DependencyType.directMain], 1);
        expect(counts[DependencyType.directDev], 1);
        expect(counts[DependencyType.transitive], 1);
        expect(counts[DependencyType.directOverridden], 0);
      });
    });
  });

  group('Given a pubspec.lock with path dependencies', () {
    const lockString = '''
packages:
  my_local_package:
    dependency: "direct main"
    description:
      path: "../my_local_package"
    source: path
    version: "1.0.0"
sdks:
  dart: ">=3.0.0 <4.0.0"
''';

    group('when calling PubspecLockParser.parse', () {
      late PubspecLockParser parser;
      late LockedPackage package;

      setUpAll(() {
        parser = PubspecLockParser.parse(lockString);
        package = parser.getPackage('my_local_package')!;
      });

      test('then package has correct source', () {
        expect(package.source, PackageSource.path);
      });

      test('then package has PathDependency', () {
        expect(package.dependency, isA<PathDependency>());
      });

      test('then PathDependency has correct path', () {
        final pathDep = package.dependency as PathDependency;
        expect(pathDep.path, '../my_local_package');
      });

      test('then pathPackages returns the path package', () {
        expect(parser.pathPackages, hasLength(1));
        expect(parser.pathPackages.first.name, 'my_local_package');
      });
    });
  });

  group('Given a pubspec.lock with git dependencies', () {
    const lockString = '''
packages:
  my_git_package:
    dependency: "direct main"
    description:
      url: "https://github.com/user/repo.git"
      ref: "main"
      path: "packages/my_package"
    source: git
    version: "1.0.0"
sdks:
  dart: ">=3.0.0 <4.0.0"
''';

    group('when calling PubspecLockParser.parse', () {
      late PubspecLockParser parser;
      late LockedPackage package;

      setUpAll(() {
        parser = PubspecLockParser.parse(lockString);
        package = parser.getPackage('my_git_package')!;
      });

      test('then package has correct source', () {
        expect(package.source, PackageSource.git);
      });

      test('then package has GitDependency', () {
        expect(package.dependency, isA<GitDependency>());
      });

      test('then GitDependency has correct url', () {
        final gitDep = package.dependency as GitDependency;
        expect(gitDep.url, Uri.parse('https://github.com/user/repo.git'));
      });

      test('then GitDependency has correct ref', () {
        final gitDep = package.dependency as GitDependency;
        expect(gitDep.ref, 'main');
      });

      test('then GitDependency has correct path', () {
        final gitDep = package.dependency as GitDependency;
        expect(gitDep.path, 'packages/my_package');
      });

      test('then gitPackages returns the git package', () {
        expect(parser.gitPackages, hasLength(1));
        expect(parser.gitPackages.first.name, 'my_git_package');
      });
    });
  });

  group('Given a pubspec.lock with SDK dependencies', () {
    const lockString = '''
packages:
  flutter:
    dependency: "direct main"
    description: flutter
    source: sdk
    version: "0.0.0"
  _macros:
    dependency: transitive
    description: dart
    source: sdk
    version: "0.3.3"
sdks:
  dart: ">=3.0.0 <4.0.0"
''';

    group('when calling PubspecLockParser.parse', () {
      late PubspecLockParser parser;
      late LockedPackage flutterPackage;
      late LockedPackage macrosPackage;

      setUpAll(() {
        parser = PubspecLockParser.parse(lockString);
        flutterPackage = parser.getPackage('flutter')!;
        macrosPackage = parser.getPackage('_macros')!;
      });

      test('then flutter package has correct source', () {
        expect(flutterPackage.source, PackageSource.sdk);
      });

      test('then flutter package has SdkDependency', () {
        expect(flutterPackage.dependency, isA<SdkDependency>());
      });

      test('then flutter SdkDependency has correct sdk', () {
        final sdkDep = flutterPackage.dependency as SdkDependency;
        expect(sdkDep.sdk, 'flutter');
      });

      test('then _macros package has SdkDependency with dart sdk', () {
        final sdkDep = macrosPackage.dependency as SdkDependency;
        expect(sdkDep.sdk, 'dart');
      });

      test('then sdkPackages returns the SDK packages', () {
        expect(parser.sdkPackages, hasLength(2));
        expect(
          parser.sdkPackages.map((p) => p.name),
          unorderedEquals(['flutter', '_macros']),
        );
      });
    });
  });

  group('Given a pubspec.lock with dependency overrides', () {
    const lockString = '''
packages:
  overridden_package:
    dependency: "direct overridden"
    description:
      name: overridden_package
      sha256: "abc123"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
sdks:
  dart: ">=3.0.0 <4.0.0"
''';

    group('when calling PubspecLockParser.parse', () {
      late PubspecLockParser parser;
      late LockedPackage package;

      setUpAll(() {
        parser = PubspecLockParser.parse(lockString);
        package = parser.getPackage('overridden_package')!;
      });

      test('then package has correct dependency type', () {
        expect(package.dependencyType, DependencyType.directOverridden);
        expect(package.isDirect, true);
      });

      test('then getPackagesByType returns overridden package', () {
        final overridden =
            parser.getPackagesByType(DependencyType.directOverridden);
        expect(overridden, hasLength(1));
        expect(overridden.first.name, 'overridden_package');
      });
    });
  });

  group('Given an invalid pubspec.lock', () {
    group('when YAML is not a map', () {
      const lockString = 'invalid yaml string';

      test('then parsing throws FormatException', () {
        expect(
          () => PubspecLockParser.parse(lockString),
          throwsA(isA<FormatException>()),
        );
      });
    });

    group('when dependency type is unknown', () {
      const lockString = '''
packages:
  test_package:
    dependency: "unknown type"
    description:
      name: test_package
    source: hosted
    version: "1.0.0"
''';

      test('then parsing throws ArgumentError', () {
        expect(
          () => PubspecLockParser.parse(lockString),
          throwsA(isA<ArgumentError>()),
        );
      });
    });

    group('when source type is unknown', () {
      const lockString = '''
packages:
  test_package:
    dependency: "direct main"
    description:
      name: test_package
    source: unknown_source
    version: "1.0.0"
''';

      test('then parsing throws ArgumentError', () {
        expect(
          () => PubspecLockParser.parse(lockString),
          throwsA(isA<ArgumentError>()),
        );
      });
    });
  });

  group('Given an empty pubspec.lock', () {
    const lockString = '''
packages: {}
sdks:
  dart: ">=3.0.0 <4.0.0"
''';

    group('when calling PubspecLockParser.parse', () {
      late PubspecLockParser parser;

      setUpAll(() {
        parser = PubspecLockParser.parse(lockString);
      });

      test('then it returns no packages', () {
        expect(parser.allPackages, isEmpty);
      });

      test('then all package lists are empty', () {
        expect(parser.directDependencies, isEmpty);
        expect(parser.devDependencies, isEmpty);
        expect(parser.transitiveDependencies, isEmpty);
        expect(parser.hostedPackages, isEmpty);
        expect(parser.pathPackages, isEmpty);
        expect(parser.gitPackages, isEmpty);
        expect(parser.sdkPackages, isEmpty);
      });

      test('then SDK constraint is parsed correctly', () {
        expect(parser.dartSdkConstraint?.toString(), '>=3.0.0 <4.0.0');
      });
    });
  });
}
